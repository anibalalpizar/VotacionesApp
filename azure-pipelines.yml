# Automatically trigger pipeline on push to main branch
trigger:
  - main

# Use self-hosted agent pool
pool:
  name: 'LocalPool'

# Pipeline variables
variables:
  buildConfiguration: 'Release'  # Build in Release mode for production optimization
  dotnetVersion: '8.x'           # .NET SDK version to use

steps:

# Step 1: Install .NET SDK
# Downloads and installs the specified .NET SDK version on the build agent
- task: UseDotNet@2
  displayName: 'Install .NET SDK $(dotnetVersion)'
  inputs:
    packageType: 'sdk'
    version: '$(dotnetVersion)'
    installationPath: $(Agent.ToolsDirectory)/dotnet

# Step 2: Restore NuGet packages
# Restores all project dependencies from NuGet before building
- script: |
    echo Restoring dependencies...
    dotnet restore server/server.sln --verbosity normal
  displayName: 'Restore NuGet packages'

# Step 3: Build the solution
# Compiles the entire solution in Release mode without restoring packages again
- script: |
    echo Building solution...
    dotnet build server/server.sln --configuration $(buildConfiguration) --no-restore
  displayName: 'Build solution in $(buildConfiguration) mode'

# Step 4: Run unit tests
# Executes all unit tests and generates TRX report files
- script: |
    echo Running unit tests...
    dotnet test server/UnitTests/UnitTests.csproj --no-build --configuration $(buildConfiguration) --logger trx --results-directory server/UnitTests/TestResults
  displayName: 'Run unit tests'

# Step 5: Run integration tests
# Executes all integration tests and generates TRX report files
- script: |
    echo Running integration tests...
    dotnet test server/IntegrationTest/IntegrationTest.csproj --no-build --configuration $(buildConfiguration) --logger trx --results-directory server/IntegrationTest/TestResults
  displayName: 'Run integration tests'

# Step 6: Publish unit test results
# Uploads unit test results to Azure DevOps for visualization
# Runs even if previous steps failed to ensure test results are always published
- task: PublishTestResults@2
  displayName: 'Publish unit test results'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/UnitTests/TestResults/**/*.trx'
    searchFolder: '$(System.DefaultWorkingDirectory)'
    mergeTestResults: false
    failTaskOnFailedTests: false
    testRunTitle: 'Unit Tests - VotacionesApp'
  condition: succeededOrFailed()

# Step 7: Publish integration test results
# Uploads integration test results to Azure DevOps for visualization
# Pipeline will fail if integration tests fail (failTaskOnFailedTests: true)
- task: PublishTestResults@2
  displayName: 'Publish integration test results'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/IntegrationTest/TestResults/**/*.trx'
    searchFolder: '$(System.DefaultWorkingDirectory)'
    mergeTestResults: false
    failTaskOnFailedTests: true
    testRunTitle: 'Integration Tests - VotacionesApp'
  condition: succeededOrFailed()

# Step 8: Generate build artifacts (optional)
# Creates a publishable version of the application
# Only runs if all previous steps succeeded
- script: |
    echo Generating artifacts...
    dotnet publish server/server.sln --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/VotacionesApp --no-build
  displayName: 'Generate build artifacts'
  condition: succeeded()

# Step 9: Publish artifacts to Azure DevOps (optional)
# Uploads compiled binaries to Azure Artifacts for storage and deployment
# Only runs if all previous steps succeeded
- task: PublishBuildArtifacts@1
  displayName: 'Publish artifacts to Azure DevOps'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/VotacionesApp'
    ArtifactName: 'VotacionesApp-$(Build.BuildId)'
    publishLocation: 'Container'
  condition: succeeded()