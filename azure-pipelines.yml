# ====================================================================
# Pipeline de Integraci贸n Continua (CI) para VotacionesApp
# Curso: ISW-1411 Calidad del Software
# Plataforma: Azure DevOps
# Framework: .NET 8.x
# ====================================================================

# Trigger: El pipeline se ejecuta autom谩ticamente despu茅s de cada commit (push) a la rama main
trigger:
  - main

# Pool: Define el agente de ejecuci贸n donde se ejecutar谩 el pipeline
# Usando agente local self-hosted
pool:
  name: 'LocalPool'

# Variables globales del pipeline
variables:
  buildConfiguration: 'Release'  # Compilaci贸n en modo Release (optimizado para producci贸n)
  dotnetVersion: '8.x'           # Versi贸n del SDK de .NET a utilizar

# ====================================================================
# STEPS: Pasos secuenciales del pipeline CI
# ====================================================================
steps:

# --------------------------------------------------------------------
# PASO 1: Instalar el SDK de .NET
# --------------------------------------------------------------------
# Configura el entorno con la versi贸n espec铆fica del SDK de .NET
- task: UseDotNet@2
  displayName: ' Instalar .NET SDK $(dotnetVersion)'
  inputs:
    packageType: 'sdk'
    version: '$(dotnetVersion)'
    installationPath: $(Agent.ToolsDirectory)/dotnet

# --------------------------------------------------------------------
# PASO 2: Restaurar dependencias de TODA la soluci贸n
# --------------------------------------------------------------------
# Descarga todos los paquetes NuGet necesarios para TODO el proyecto
# Usa el archivo server.sln para restaurar toda la soluci贸n
- script: |
    cd server
    dotnet restore server.sln --verbosity normal
  displayName: ' Restaurar dependencias (NuGet packages)'

# --------------------------------------------------------------------
# PASO 3: Compilar TODO el proyecto (incluyendo pruebas)
# --------------------------------------------------------------------
# Compila toda la soluci贸n respetando las dependencias entre proyectos
- script: |
    cd server
    dotnet build server.sln --configuration $(buildConfiguration) --no-restore
  displayName: ' Compilar proyecto completo en modo $(buildConfiguration)'

# --------------------------------------------------------------------
# PASO 4: Ejecutar pruebas unitarias
# --------------------------------------------------------------------
# Ejecuta las pruebas unitarias SIN recompilar (ya est谩n compiladas)
# Genera reporte .trx y datos de cobertura de c贸digo
- script: |
    cd server/UnitTests
    dotnet test --no-build --configuration $(buildConfiguration) --logger trx --results-directory TestResults --collect:"XPlat Code Coverage"
  displayName: 'И Ejecutar pruebas unitarias'

# --------------------------------------------------------------------
# PASO 5: Ejecutar pruebas de integraci贸n (REQUIERE DOCKER)
# --------------------------------------------------------------------
# Ejecuta las pruebas de integraci贸n SIN recompilar
# NOTA: Estas pruebas requieren Docker. Se omiten si Docker no est谩 disponible.
# Para habilitar: instala Docker Desktop en el agente o usa un agente con Docker
- script: |
    cd server/IntegrationTest
    dotnet test --no-build --configuration $(buildConfiguration) --logger trx --results-directory TestResults --collect:"XPlat Code Coverage"
  displayName: ' Ejecutar pruebas de integraci贸n (requiere Docker)'
  continueOnError: true

# --------------------------------------------------------------------
# PASO 6: DEBUG - Explorar estructura de archivos
# --------------------------------------------------------------------
# Este paso ayuda a diagnosticar problemas mostrando qu茅 archivos se generaron
- script: |
    echo === Directorio de trabajo actual ===
    cd
    echo.
    echo === Estructura del directorio server ===
    dir server /s /b | findstr /i "\.csproj \.sln"
    echo.
    echo === Contenido de server/UnitTests/TestResults ===
    dir server\UnitTests\TestResults /s 2>nul || echo No existe el directorio
    echo.
    echo === Contenido de server/IntegrationTest/TestResults ===
    dir server\IntegrationTest\TestResults /s 2>nul || echo No existe el directorio
    echo.
    echo === Buscando TODOS los archivos .trx ===
    where /r server *.trx 2>nul || echo No se encontraron archivos .trx
    echo.
    echo === Buscando TODOS los archivos de cobertura ===
    where /r server *coverage*.xml 2>nul || echo No se encontraron archivos de cobertura
  displayName: ' DEBUG - Explorar archivos generados'
  condition: always()

# --------------------------------------------------------------------
# PASO 7: Publicar resultados de pruebas unitarias
# --------------------------------------------------------------------
# Publica los resultados de las pruebas unitarias en Azure DevOps
# Estos se pueden visualizar en la pesta帽a "Tests" del pipeline
- task: PublishTestResults@2
  displayName: ' Publicar resultados de pruebas unitarias'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/UnitTests/TestResults/**/*.trx'
    searchFolder: '$(System.DefaultWorkingDirectory)'
    mergeTestResults: false
    failTaskOnFailedTests: true
    testRunTitle: 'Pruebas Unitarias - VotacionesApp'
  condition: succeededOrFailed()

# --------------------------------------------------------------------
# PASO 8: Publicar resultados de pruebas de integraci贸n
# --------------------------------------------------------------------
# Publica los resultados de las pruebas de integraci贸n en Azure DevOps
# No falla el pipeline si no hay pruebas de integraci贸n disponibles
- task: PublishTestResults@2
  displayName: ' Publicar resultados de pruebas de integraci贸n'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/IntegrationTest/TestResults/**/*.trx'
    searchFolder: '$(System.DefaultWorkingDirectory)'
    mergeTestResults: false
    failTaskOnFailedTests: false
    testRunTitle: 'Pruebas de Integraci贸n - VotacionesApp (requiere Docker)'
  condition: succeededOrFailed()

# --------------------------------------------------------------------
# PASO 9: Publicar cobertura de c贸digo
# --------------------------------------------------------------------
# Publica los reportes de cobertura de c贸digo en Azure DevOps
# Esto permite visualizar qu茅 porcentaje del c贸digo est谩 cubierto por pruebas
- task: PublishCodeCoverageResults@2
  displayName: ' Publicar cobertura de c贸digo'
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/TestResults/**/coverage.cobertura.xml'
    failIfCoverageEmpty: false
  condition: succeededOrFailed()

# --------------------------------------------------------------------
# PASO 10 (OPCIONAL): Publicar artefactos de compilaci贸n
# --------------------------------------------------------------------
# Genera los archivos binarios listos para despliegue
# Publica espec铆ficamente el proyecto server (aplicaci贸n principal)
- script: |
    cd server
    dotnet publish server/server.csproj --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/VotacionesApp --no-build
  displayName: ' Generar artefactos de publicaci贸n'
  condition: succeeded()

# --------------------------------------------------------------------
# PASO 11 (OPCIONAL): Publicar artefactos en Azure Pipelines
# --------------------------------------------------------------------
# Sube los artefactos generados a Azure DevOps para su descarga o despliegue
- task: PublishBuildArtifacts@1
  displayName: '锔 Publicar artefactos en Azure DevOps'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/VotacionesApp'
    ArtifactName: 'VotacionesApp-$(Build.BuildId)'
    publishLocation: 'Container'
  condition: succeeded()

# ====================================================================
# CAMBIOS REALIZADOS EN ESTA VERSIN:
# ====================================================================
# 1. AGREGADA detecci贸n autom谩tica de archivo .sln
#    Si existe un .sln, se usa para compilar toda la soluci贸n
#    Esto resuelve las referencias entre proyectos correctamente
#
# 2. RESTAURADO el uso de --no-build en dotnet test
#    Ahora que la compilaci贸n completa funciona, podemos usar --no-build
#
# 3. MEJORADO el paso de DEBUG para mostrar la estructura de proyectos
#    Ahora muestra todos los .csproj y .sln encontrados
#
# ====================================================================
# SOLUCIN AL ERROR "Server not found":
# ====================================================================
# El error ocurr铆a porque los proyectos se compilaban de forma aislada
# sin respetar las referencias entre proyectos. Ahora:
#
# 1. Se compila toda la soluci贸n en un solo paso
# 2. .NET resuelve autom谩ticamente las dependencias entre proyectos
# 3. Los binarios se generan en el orden correcto
# 4. Las pruebas pueden encontrar todas las referencias necesarias
# ====================================================================
# NOTAS ADICIONALES:
# ====================================================================
# 1. Este pipeline implementa "Shift Left Testing" al ejecutar pruebas
#    autom谩ticamente en cada commit
#
# 2. failTaskOnFailedTests: true asegura que el pipeline falle si hay
#    pruebas que no pasan, manteniendo el "build verde"
#
# 3. Los reportes .trx se pueden visualizar en la pesta帽a "Tests" de
#    Azure DevOps despu茅s de cada ejecuci贸n
#
# 4. La cobertura de c贸digo ayuda a identificar 谩reas sin probar
#
# 5. Los artefactos permiten mantener un historial de versiones
#    compiladas y facilitan el despliegue continuo (CD)
#
# 6. condition: succeededOrFailed() permite que los reportes se publiquen
#    incluso si las pruebas fallan, para poder ver qu茅 sali贸 mal
#
# 7. Si NO tienes un archivo .sln, cr茅alo con:
#    dotnet new sln -n VotacionesApp
#    dotnet sln add server/server.csproj
#    dotnet sln add server/EleccionesUTN/EleccionesUTN.csproj
#    dotnet sln add server/UnitTests/UnitTests.csproj
#    dotnet sln add server/IntegrationTest/IntegrationTest.csproj
# ====================================================================