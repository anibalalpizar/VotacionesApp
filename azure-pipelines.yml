# ====================================================================
# Pipeline de Integración Continua (CI) para VotacionesApp
# Curso: ISW-1411 Calidad del Software
# Plataforma: Azure DevOps
# Framework: .NET 8.x
# ====================================================================

# Trigger: El pipeline se ejecuta automáticamente después de cada commit (push) a la rama main
trigger:
  - main

# Pool: Define el agente de ejecución donde se ejecutará el pipeline
# Usando agente local self-hosted
pool:
  name: 'LocalPool'

# Variables globales del pipeline
variables:
  buildConfiguration: 'Release'  # Compilación en modo Release (optimizado para producción)
  dotnetVersion: '8.x'           # Versión del SDK de .NET a utilizar

# ====================================================================
# STEPS: Pasos secuenciales del pipeline CI
# ====================================================================
steps:

# --------------------------------------------------------------------
# PASO 1: Instalar el SDK de .NET
# --------------------------------------------------------------------
# Configura el entorno con la versión específica del SDK de .NET
- task: UseDotNet@2
  displayName: '📦 Instalar .NET SDK $(dotnetVersion)'
  inputs:
    packageType: 'sdk'
    version: '$(dotnetVersion)'
    installationPath: $(Agent.ToolsDirectory)/dotnet

# --------------------------------------------------------------------
# PASO 2: Restaurar dependencias del proyecto
# --------------------------------------------------------------------
# Descarga todos los paquetes NuGet necesarios para el proyecto
- script: |
    cd server
    dotnet restore
  displayName: '🔄 Restaurar dependencias (NuGet packages)'

# --------------------------------------------------------------------
# PASO 3: Compilar el proyecto
# --------------------------------------------------------------------
# Genera la compilación del código en modo Release
# --configuration Release: Compila con optimizaciones de producción
# --no-restore: No restaura dependencias (ya se hizo en el paso anterior)
- script: |
    cd server
    dotnet build --configuration $(buildConfiguration) --no-restore
  displayName: '🔨 Compilar proyecto en modo $(buildConfiguration)'

# --------------------------------------------------------------------
# PASO 4: Ejecutar pruebas unitarias
# --------------------------------------------------------------------
# Ejecuta todas las pruebas del proyecto UnitTests
# Los resultados se guardan automáticamente en TestResults dentro del proyecto
- script: |
    cd server/UnitTests
    dotnet test --no-build --configuration $(buildConfiguration) --verbosity normal --logger trx --collect:"XPlat Code Coverage"
  displayName: '🧪 Ejecutar pruebas unitarias'

# --------------------------------------------------------------------
# PASO 5: Ejecutar pruebas de integración
# --------------------------------------------------------------------
# Ejecuta todas las pruebas del proyecto IntegrationTest
- script: |
    cd server/IntegrationTest
    dotnet test --no-build --configuration $(buildConfiguration) --verbosity normal --logger trx --collect:"XPlat Code Coverage"
  displayName: '🔗 Ejecutar pruebas de integración'

# --------------------------------------------------------------------
# PASO 6: Publicar resultados de pruebas unitarias
# --------------------------------------------------------------------
# Publica los resultados de las pruebas unitarias en Azure DevOps
- task: PublishTestResults@2
  displayName: '📊 Publicar resultados de pruebas unitarias'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/UnitTests/TestResults/**/*.trx'
    searchFolder: '$(System.DefaultWorkingDirectory)'
    mergeTestResults: false
    failTaskOnFailedTests: true
    testRunTitle: 'Pruebas Unitarias - VotacionesApp'
  condition: succeededOrFailed()

# --------------------------------------------------------------------
# PASO 7: Publicar resultados de pruebas de integración
# --------------------------------------------------------------------
# Publica los resultados de las pruebas de integración en Azure DevOps
- task: PublishTestResults@2
  displayName: '📊 Publicar resultados de pruebas de integración'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/IntegrationTest/TestResults/**/*.trx'
    searchFolder: '$(System.DefaultWorkingDirectory)'
    mergeTestResults: false
    failTaskOnFailedTests: true
    testRunTitle: 'Pruebas de Integración - VotacionesApp'
  condition: succeededOrFailed()

# --------------------------------------------------------------------
# PASO 8: Publicar cobertura de código
# --------------------------------------------------------------------
# Publica los reportes de cobertura de código en Azure DevOps
- task: PublishCodeCoverageResults@2
  displayName: '📈 Publicar cobertura de código'
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/coverage.cobertura.xml'
    failIfCoverageEmpty: false
  condition: succeededOrFailed()

# --------------------------------------------------------------------
# PASO 9 (OPCIONAL): Publicar artefactos de compilación
# --------------------------------------------------------------------
# Genera un artefacto con los binarios compilados del proyecto
- script: |
    cd server
    dotnet publish --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/VotacionesApp --no-build
  displayName: '📦 Generar artefactos de publicación'
  condition: succeeded()

# --------------------------------------------------------------------
# PASO 10 (OPCIONAL): Publicar artefactos en Azure Pipelines
# --------------------------------------------------------------------
# Sube los artefactos generados a Azure DevOps
- task: PublishBuildArtifacts@1
  displayName: '☁️ Publicar artefactos en Azure DevOps'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/VotacionesApp'
    ArtifactName: 'VotacionesApp-$(Build.BuildId)'
    publishLocation: 'Container'
  condition: succeeded()

# ====================================================================
# NOTAS ADICIONALES:
# ====================================================================
# 1. Este pipeline implementa "Shift Left Testing" al ejecutar pruebas
#    automáticamente en cada commit
#
# 2. failTaskOnFailedTests: true asegura que el pipeline falle si hay
#    pruebas que no pasan, manteniendo el "build verde"
#
# 3. Los reportes .trx se pueden visualizar en la pestaña "Tests" de
#    Azure DevOps después de cada ejecución
#
# 4. La cobertura de código ayuda a identificar áreas sin probar
#
# 5. Los artefactos permiten mantener un historial de versiones
#    compiladas y facilitan el despliegue continuo (CD)
# ====================================================================